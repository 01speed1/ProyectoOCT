/*!
 * morgan
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module exports.
 * @public
 */

module.exports = morgan
module.exports.compile = compile
module.exports.format = format
module.exports.token = token

/**
 * Module dependencies.
 * @private
 */

var auth = require('basic-auth')
var debug = require('debug')('morgan')
var deprecate = require('depd')('morgan')
var onFinished = require('on-finished')
var onHeaders = require('on-headers')

/**
 * Array of CLF month names.
 * @private
 */

<<<<<<< HEAD
var CLF_MONTH = [
=======
var clfmonth = [
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
]

/**
 * Default log buffer duration.
 * @private
 */

<<<<<<< HEAD
var DEFAULT_BUFFER_DURATION = 1000
=======
var defaultBufferDuration = 1000;
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df

/**
 * Create a logger middleware.
 *
 * @public
 * @param {String|Function} format
 * @param {Object} [options]
 * @return {Function} middleware
 */

<<<<<<< HEAD
function morgan (format, options) {
=======
function morgan(format, options) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  var fmt = format
  var opts = options || {}

  if (format && typeof format === 'object') {
    opts = format
    fmt = opts.format || 'default'

    // smart deprecation message
    deprecate('morgan(options): use morgan(' + (typeof fmt === 'string' ? JSON.stringify(fmt) : 'format') + ', options) instead')
  }

  if (fmt === undefined) {
    deprecate('undefined format: specify a format')
  }

  // output on request instead of response
  var immediate = opts.immediate

  // check if log entry should be skipped
  var skip = opts.skip || false

  // format function
  var formatLine = typeof fmt !== 'function'
    ? getFormatFunction(fmt)
    : fmt

  // stream
  var buffer = opts.buffer
  var stream = opts.stream || process.stdout

  // buffering support
  if (buffer) {
    deprecate('buffer option')

    // flush interval
    var interval = typeof buffer !== 'number'
<<<<<<< HEAD
      ? DEFAULT_BUFFER_DURATION
=======
      ? defaultBufferDuration
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
      : buffer

    // swap the stream
    stream = createBufferStream(stream, interval)
  }

<<<<<<< HEAD
  return function logger (req, res, next) {
=======
  return function logger(req, res, next) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
    // request data
    req._startAt = undefined
    req._startTime = undefined
    req._remoteAddress = getip(req)

    // response data
    res._startAt = undefined
    res._startTime = undefined

    // record request start
    recordStartTime.call(req)

<<<<<<< HEAD
    function logRequest () {
=======
    function logRequest() {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
      if (skip !== false && skip(req, res)) {
        debug('skip request')
        return
      }

      var line = formatLine(morgan, req, res)

<<<<<<< HEAD
      if (line == null) {
=======
      if (null == line) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
        debug('skip line')
        return
      }

      debug('log request')
      stream.write(line + '\n')
    };

    if (immediate) {
      // immediate log
      logRequest()
    } else {
      // record response start
      onHeaders(res, recordStartTime)

      // log when response finished
      onFinished(res, logRequest)
    }

<<<<<<< HEAD
    next()
  }
=======
    next();
  };
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
}

/**
 * Apache combined log format.
 */

morgan.format('combined', ':remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" :status :res[content-length] ":referrer" ":user-agent"')

/**
 * Apache common log format.
 */

morgan.format('common', ':remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" :status :res[content-length]')

/**
 * Default format.
 */

morgan.format('default', ':remote-addr - :remote-user [:date] ":method :url HTTP/:http-version" :status :res[content-length] ":referrer" ":user-agent"')
deprecate.property(morgan, 'default', 'default format: use combined format')

/**
 * Short format.
 */

morgan.format('short', ':remote-addr :remote-user :method :url HTTP/:http-version :status :res[content-length] - :response-time ms')

/**
 * Tiny format.
 */

morgan.format('tiny', ':method :url :status :res[content-length] - :response-time ms')

/**
 * dev (colored)
 */

<<<<<<< HEAD
morgan.format('dev', function developmentFormatLine (tokens, req, res) {
=======
morgan.format('dev', function developmentFormatLine(tokens, req, res) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  // get the status code if response written
  var status = res._header
    ? res.statusCode
    : undefined

  // get status color
  var color = status >= 500 ? 31 // red
    : status >= 400 ? 33 // yellow
    : status >= 300 ? 36 // cyan
    : status >= 200 ? 32 // green
    : 0 // no color

  // get colored function
  var fn = developmentFormatLine[color]

  if (!fn) {
    // compile
<<<<<<< HEAD
    fn = developmentFormatLine[color] = compile('\x1b[0m:method :url \x1b[' +
      color + 'm:status \x1b[0m:response-time ms - :res[content-length]\x1b[0m')
=======
    fn = developmentFormatLine[color] = compile('\x1b[0m:method :url \x1b['
      + color + 'm:status \x1b[0m:response-time ms - :res[content-length]\x1b[0m')
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  }

  return fn(tokens, req, res)
})

/**
 * request url
 */

<<<<<<< HEAD
morgan.token('url', function getUrlToken (req) {
=======
morgan.token('url', function getUrlToken(req) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  return req.originalUrl || req.url
})

/**
 * request method
 */

<<<<<<< HEAD
morgan.token('method', function getMethodToken (req) {
  return req.method
})
=======
morgan.token('method', function getMethodToken(req) {
  return req.method;
});
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df

/**
 * response time in milliseconds
 */

<<<<<<< HEAD
morgan.token('response-time', function getResponseTimeToken (req, res, digits) {
=======
morgan.token('response-time', function getResponseTimeToken(req, res, digits) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  if (!req._startAt || !res._startAt) {
    // missing request and/or response start time
    return
  }

  // calculate diff
<<<<<<< HEAD
  var ms = (res._startAt[0] - req._startAt[0]) * 1e3 +
    (res._startAt[1] - req._startAt[1]) * 1e-6
=======
  var ms = (res._startAt[0] - req._startAt[0]) * 1e3
    + (res._startAt[1] - req._startAt[1]) * 1e-6
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df

  // return truncated value
  return ms.toFixed(digits === undefined ? 3 : digits)
})

/**
 * current date
 */

<<<<<<< HEAD
morgan.token('date', function getDateToken (req, res, format) {
=======
morgan.token('date', function getDateToken(req, res, format) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  var date = new Date()

  switch (format || 'web') {
    case 'clf':
      return clfdate(date)
    case 'iso':
      return date.toISOString()
    case 'web':
      return date.toUTCString()
  }
<<<<<<< HEAD
})
=======
});
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df

/**
 * response status code
 */

<<<<<<< HEAD
morgan.token('status', function getStatusToken (req, res) {
=======
morgan.token('status', function getStatusToken(req, res) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  return res._header
    ? String(res.statusCode)
    : undefined
})

/**
 * normalized referrer
 */

<<<<<<< HEAD
morgan.token('referrer', function getReferrerToken (req) {
  return req.headers['referer'] || req.headers['referrer']
})
=======
morgan.token('referrer', function getReferrerToken(req) {
  return req.headers['referer'] || req.headers['referrer'];
});
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df

/**
 * remote address
 */

morgan.token('remote-addr', getip)

/**
 * remote user
 */

<<<<<<< HEAD
morgan.token('remote-user', function getRemoteUserToken (req) {
=======
morgan.token('remote-user', function getRemoteUserToken(req) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  // parse basic credentials
  var credentials = auth(req)

  // return username
  return credentials
    ? credentials.name
    : undefined
})

/**
 * HTTP version
 */

<<<<<<< HEAD
morgan.token('http-version', function getHttpVersionToken (req) {
=======
morgan.token('http-version', function getHttpVersionToken(req) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  return req.httpVersionMajor + '.' + req.httpVersionMinor
})

/**
 * UA string
 */

<<<<<<< HEAD
morgan.token('user-agent', function getUserAgentToken (req) {
  return req.headers['user-agent']
})
=======
morgan.token('user-agent', function getUserAgentToken(req) {
  return req.headers['user-agent'];
});
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df

/**
 * request header
 */

<<<<<<< HEAD
morgan.token('req', function getRequestToken (req, res, field) {
=======
morgan.token('req', function getRequestToken(req, res, field) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  // get header
  var header = req.headers[field.toLowerCase()]

  return Array.isArray(header)
    ? header.join(', ')
    : header
})

/**
 * response header
 */

<<<<<<< HEAD
morgan.token('res', function getResponseHeader (req, res, field) {
=======
morgan.token('res', function getResponseTime(req, res, field) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  if (!res._header) {
    return undefined
  }

  // get header
  var header = res.getHeader(field)

  return Array.isArray(header)
    ? header.join(', ')
    : header
})

/**
 * Format a Date in the common log format.
 *
 * @private
 * @param {Date} dateTime
 * @return {string}
 */

<<<<<<< HEAD
function clfdate (dateTime) {
=======
function clfdate(dateTime) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  var date = dateTime.getUTCDate()
  var hour = dateTime.getUTCHours()
  var mins = dateTime.getUTCMinutes()
  var secs = dateTime.getUTCSeconds()
  var year = dateTime.getUTCFullYear()

<<<<<<< HEAD
  var month = CLF_MONTH[dateTime.getUTCMonth()]

  return pad2(date) + '/' + month + '/' + year +
    ':' + pad2(hour) + ':' + pad2(mins) + ':' + pad2(secs) +
    ' +0000'
=======
  var month = clfmonth[dateTime.getUTCMonth()]

  return pad2(date) + '/' + month + '/' + year
    + ':' + pad2(hour) + ':' + pad2(mins) + ':' + pad2(secs)
    + ' +0000'
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
}

/**
 * Compile a format string into a function.
 *
 * @param {string} format
 * @return {function}
 * @public
 */

<<<<<<< HEAD
function compile (format) {
=======
function compile(format) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  if (typeof format !== 'string') {
    throw new TypeError('argument format must be a string')
  }

  var fmt = format.replace(/"/g, '\\"')
<<<<<<< HEAD
  var js = '  "use strict"\n  return "' + fmt.replace(/:([-\w]{2,})(?:\[([^\]]+)\])?/g, function (_, name, arg) {
    var tokenArguments = 'req, res'
    var tokenFunction = 'tokens[' + String(JSON.stringify(name)) + ']'

    if (arg !== undefined) {
      tokenArguments += ', ' + String(JSON.stringify(arg))
    }

    return '" +\n    (' + tokenFunction + '(' + tokenArguments + ') || "-") + "'
  }) + '"'

  // eslint-disable-next-line no-new-func
=======
  var js = '  return "' + fmt.replace(/:([-\w]{2,})(?:\[([^\]]+)\])?/g, function(_, name, arg) {
    return '"\n    + (tokens["' + name + '"](req, res, ' + String(JSON.stringify(arg)) + ') || "-") + "'
  }) + '";'

>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  return new Function('tokens, req, res', js)
}

/**
 * Create a basic buffering stream.
 *
 * @param {object} stream
 * @param {number} interval
 * @public
 */

<<<<<<< HEAD
function createBufferStream (stream, interval) {
=======
function createBufferStream(stream, interval) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  var buf = []
  var timer = null

  // flush function
<<<<<<< HEAD
  function flush () {
=======
  function flush() {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
    timer = null
    stream.write(buf.join(''))
    buf.length = 0
  }

  // write function
<<<<<<< HEAD
  function write (str) {
=======
  function write(str) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
    if (timer === null) {
      timer = setTimeout(flush, interval)
    }

    buf.push(str)
  }

  // return a minimal "stream"
  return { write: write }
}

/**
 * Define a format with the given name.
 *
 * @param {string} name
 * @param {string|function} fmt
 * @public
 */

<<<<<<< HEAD
function format (name, fmt) {
=======
function format(name, fmt) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  morgan[name] = fmt
  return this
}

/**
 * Lookup and compile a named format function.
 *
 * @param {string} name
 * @return {function}
 * @public
 */

<<<<<<< HEAD
function getFormatFunction (name) {
=======
function getFormatFunction(name) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  // lookup format
  var fmt = morgan[name] || name || morgan.default

  // return compiled format
  return typeof fmt !== 'function'
    ? compile(fmt)
    : fmt
}

/**
 * Get request IP address.
 *
 * @private
 * @param {IncomingMessage} req
 * @return {string}
 */

<<<<<<< HEAD
function getip (req) {
  return req.ip ||
    req._remoteAddress ||
    (req.connection && req.connection.remoteAddress) ||
    undefined
=======
function getip(req) {
  return req.ip
    || req._remoteAddress
    || (req.connection && req.connection.remoteAddress)
    || undefined;
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
}

/**
 * Pad number to two digits.
 *
 * @private
 * @param {number} num
 * @return {string}
 */

<<<<<<< HEAD
function pad2 (num) {
  var str = String(num)

  return (str.length === 1 ? '0' : '') + str
=======
function pad2(num) {
  var str = String(num)

  return (str.length === 1 ? '0' : '')
    + str
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
}

/**
 * Record the start time.
 * @private
 */

<<<<<<< HEAD
function recordStartTime () {
=======
function recordStartTime() {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  this._startAt = process.hrtime()
  this._startTime = new Date()
}

/**
 * Define a token function with the given name,
 * and callback fn(req, res).
 *
 * @param {string} name
 * @param {function} fn
 * @public
 */

<<<<<<< HEAD
function token (name, fn) {
=======
function token(name, fn) {
>>>>>>> 61e6907ab66902c521df8d20bf4a0ef28a1873df
  morgan[name] = fn
  return this
}
